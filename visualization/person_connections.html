<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Epstein Files - Person Connections</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ”—</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #fff;
            font-weight: 500;
        }

        .layout {
            display: grid;
            grid-template-columns: 320px 480px 1fr;
            gap: 20px;
            height: calc(100vh - 100px);
        }

        .panel {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 16px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .panel-title {
            font-size: 0.85rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid #333;
        }

        .search-box {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #0f0f0f;
            color: #fff;
            font-size: 0.9rem;
            margin-bottom: 12px;
        }

        .search-box:focus {
            outline: none;
            border-color: #4a9eff;
        }

        .person-list {
            flex: 1;
            overflow-y: auto;
        }

        .person-item {
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .person-item:hover {
            background: #252525;
        }

        .person-item.selected {
            background: #1e3a5f;
            color: #4a9eff;
        }

        .person-count {
            font-size: 0.75rem;
            color: #666;
            background: #252525;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .person-item.selected .person-count {
            background: #2a4a6f;
            color: #6ab0ff;
        }

        .discussions-panel {
            overflow-y: auto;
        }

        .discussion-card {
            background: #252525;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .discussion-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .discussion-metadata {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .metadata-tag {
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 4px;
        }

        .metadata-relationship {
            background: #2d1f3d;
            color: #b388ff;
        }

        .metadata-topic {
            background: #1f3d2d;
            color: #81c784;
        }

        .discussion-subject {
            font-weight: 500;
            color: #fff;
            font-size: 0.95rem;
            flex: 1;
        }

        .discussion-meta {
            font-size: 0.8rem;
            color: #666;
            text-align: right;
            margin-left: 12px;
        }

        .discussion-example {
            background: #1a1a1a;
            border-left: 3px solid #4a9eff;
            padding: 12px;
            border-radius: 0 6px 6px 0;
            font-size: 0.85rem;
            color: #b0b0b0;
            line-height: 1.5;
            margin-bottom: 12px;
        }

        .messages-container {
            margin-bottom: 12px;
        }

        .message {
            background: #1a1a1a;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
        }

        .message:last-child {
            margin-bottom: 0;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
            font-size: 0.8rem;
        }

        .message-sender {
            color: #4a9eff;
            font-weight: 500;
        }

        .message-receivers {
            color: #888;
        }

        .message-date {
            color: #666;
            font-size: 0.75rem;
        }

        .message-body {
            font-size: 0.85rem;
            color: #c0c0c0;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 300px;
            overflow-y: auto;
        }

        .message-body:empty::after {
            content: "(empty)";
            color: #555;
            font-style: italic;
        }

        .name-highlight {
            background: #4a9eff33;
            color: #6ab0ff;
            padding: 1px 3px;
            border-radius: 3px;
        }

        .discussion-people {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .person-tag {
            font-size: 0.75rem;
            padding: 3px 8px;
            border-radius: 4px;
            background: #333;
            color: #888;
        }

        .person-tag.highlighted {
            background: #1e3a5f;
            color: #4a9eff;
        }

        .empty-state {
            text-align: center;
            color: #666;
            padding: 40px 20px;
            font-size: 0.9rem;
        }

        .relationship-box {
            background: #1e2a3a;
            border: 1px solid #3a5a7a;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            max-height: 360px;
            overflow-y: auto;
        }

        .relationship-title {
            font-size: 0.75rem;
            color: #6ab0ff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .relationship-text {
            font-size: 0.8rem;
            color: #c0d0e0;
            line-height: 1.4;
        }

        .relationship-count {
            font-size: 0.75rem;
            color: #888;
            margin-top: 10px;
        }

        .thread-links {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #3a5a7a;
        }

        .thread-links-title {
            font-size: 0.7rem;
            color: #888;
            margin-bottom: 6px;
        }

        .thread-link {
            font-size: 0.7rem;
            color: #4a9eff;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            background: #1a1a1a;
            display: inline-block;
            margin: 2px;
            text-decoration: none;
        }

        .thread-link:hover {
            background: #2a4a6f;
        }

        .feedback-section {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #333;
        }

        .feedback-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #0f0f0f;
            color: #fff;
            font-size: 0.75rem;
            resize: vertical;
            min-height: 40px;
            margin-bottom: 6px;
        }

        .feedback-input:focus {
            outline: none;
            border-color: #4a9eff;
        }

        .feedback-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            margin-right: 6px;
        }

        .feedback-btn-save {
            background: #2e7d32;
            color: white;
        }

        .feedback-btn-save:hover {
            background: #388e3c;
        }

        .feedback-btn-export {
            background: #1565c0;
            color: white;
        }

        .feedback-btn-export:hover {
            background: #1976d2;
        }

        .feedback-existing {
            background: #1a2a1a;
            border: 1px solid #2e7d32;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 0.8rem;
            color: #a5d6a7;
        }

        .feedback-label {
            font-size: 0.7rem;
            color: #888;
            margin-bottom: 4px;
        }

        .feedback-count {
            font-size: 0.7rem;
            color: #666;
            margin-left: 8px;
        }

        .cluster-desc {
            background: #1a2a2a;
            border: 1px solid #2a5a5a;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            font-size: 0.8rem;
            color: #a0d0d0;
            line-height: 1.5;
            max-height: 220px;
            overflow-y: auto;
        }

        .cluster-desc-title {
            font-size: 0.7rem;
            color: #5ab0b0;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            font-size: 0.85rem;
            color: #666;
        }

        .stat-value {
            color: #4a9eff;
            font-weight: 500;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Epstein Files - Person Connections Explorer</h1>
        <div class="stats" id="stats"></div>

        <div class="layout">
            <div class="panel">
                <div class="panel-title">Select Person</div>
                <select class="search-box" id="clusterFilter" style="margin-bottom:8px;">
                    <option value="">All clusters</option>
                </select>
                <div id="clusterDescription" style="display:none;"></div>
                <input type="text" class="search-box" id="searchPerson1" placeholder="Search people...">
                <div class="person-list" id="personList1"></div>
            </div>

            <div class="panel">
                <div class="panel-title">
                    Person Info & Connections
                    <button class="feedback-btn feedback-btn-export" onclick="exportFeedbacks()" style="float:right;margin-top:-4px;">Export Feedbacks</button>
                    <span class="feedback-count" id="feedbackCount"></span>
                </div>
                <div id="relationshipInfo"></div>
                <input type="text" class="search-box" id="searchPerson2" placeholder="Filter connections...">
                <div class="person-list" id="personList2">
                    <div class="empty-state">Select a person to see their connections</div>
                </div>
            </div>

            <div class="panel discussions-panel">
                <div class="panel-title">Discussions</div>
                <div id="discussions">
                    <div class="empty-state">Select two people to see their shared discussions</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let data = [];
        let personConnections = {};
        let allPeople = [];
        let selectedPerson1 = null;
        let selectedPerson2 = null;
        let nameMapping = {};
        let personRelationships = {};
        let feedbacks = {};
        let clusterData = [];
        let personToCluster = {};
        let selectedCluster = null;

        // Load feedbacks from localStorage
        function loadFeedbacks() {
            const stored = localStorage.getItem('epstein_feedbacks');
            if (stored) {
                feedbacks = JSON.parse(stored);
            }
            updateFeedbackCount();
        }

        function saveFeedback(name, comment) {
            feedbacks[name] = comment;
            localStorage.setItem('epstein_feedbacks', JSON.stringify(feedbacks));
            updateFeedbackCount();
        }

        function updateFeedbackCount() {
            const count = Object.keys(feedbacks).length;
            document.getElementById('feedbackCount').textContent = count > 0 ? `(${count} feedbacks)` : '';
        }

        function exportFeedbacks() {
            const json = JSON.stringify(feedbacks, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'person_feedbacks.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function populateClusterFilter() {
            const select = document.getElementById('clusterFilter');
            clusterData.forEach(c => {
                const option = document.createElement('option');
                option.value = c.cluster_id;
                option.textContent = `${c.name || 'Cluster ' + c.cluster_id} (${c.size})`;
                select.appendChild(option);
            });

            select.addEventListener('change', (e) => {
                selectedCluster = e.target.value === '' ? null : parseInt(e.target.value);
                renderClusterDescription();
                renderPersonList1(document.getElementById('searchPerson1').value);
            });
        }

        function renderClusterDescription() {
            const container = document.getElementById('clusterDescription');

            if (selectedCluster === null) {
                container.style.display = 'none';
                return;
            }

            const cluster = clusterData.find(c => c.cluster_id === selectedCluster);
            if (!cluster) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';
            container.innerHTML = `
                <div class="cluster-desc">
                    <div class="cluster-desc-title">${escapeHtml(cluster.name || 'Cluster ' + cluster.cluster_id)} (${cluster.size} members)</div>
                    ${escapeHtml(cluster.analysis)}
                </div>
            `;
        }

        function consolidateName(name) {
            if (!name) return name;
            // Try exact match first
            if (nameMapping[name]) {
                const mapped = nameMapping[name];
                return mapped === 'GARBAGE' ? null : mapped;
            }
            // Try cleaned version
            let cleaned = name;
            if (cleaned.includes('<')) cleaned = cleaned.split('<')[0].trim();
            if (cleaned.includes('[')) cleaned = cleaned.split('[')[0].trim();
            cleaned = cleaned.replace(/"/g, '').trim();
            if (nameMapping[cleaned]) {
                const mapped = nameMapping[cleaned];
                return mapped === 'GARBAGE' ? null : mapped;
            }
            return cleaned || name;
        }

        async function loadData() {
            try {
                // Load name mapping first
                const mappingResponse = await fetch('data/name_matching_table.json');
                nameMapping = await mappingResponse.json();
                console.log('Loaded name mapping:', Object.keys(nameMapping).length, 'entries');

                // Load person relationships
                const relResponse = await fetch('data/person_relationships.json');
                const relData = await relResponse.json();
                relData.forEach(p => {
                    personRelationships[p.name] = p;
                });
                console.log('Loaded relationships:', Object.keys(personRelationships).length, 'entries');

                // Load cluster data
                const clusterResponse = await fetch('data/cluster_analysis.json');
                clusterData = await clusterResponse.json();
                clusterData.forEach(c => {
                    c.members.forEach(name => {
                        personToCluster[name] = c.cluster_id;
                    });
                });
                console.log('Loaded clusters:', clusterData.length);
                populateClusterFilter();

                const response = await fetch('data/epstein_discussions_filtered.json');
                data = await response.json();
                loadFeedbacks();
                processData();
                renderStats();
                renderPersonList1();
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('personList1').innerHTML =
                    '<div class="empty-state">Error loading data. Run: python -m http.server 8000</div>';
            }
        }

        function isEpstein(name) {
            if (!name) return false;
            const nameLower = name.toLowerCase();
            return nameLower.includes('epstein') ||
                   nameLower.includes('jeevacation') ||
                   ['j', 'jeffrey e.', 'je'].includes(nameLower);
        }

        function epsteinInList(names) {
            return names && names.some(n => isEpstein(n));
        }

        function shouldExcludeThread(thread) {
            // Exclude single-message threads where Epstein receives but doesn't respond
            if (thread.message_count !== 1) return false;

            const messages = thread.messages || [];
            let epsteinReceived = false;
            let epsteinSent = false;

            for (const msg of messages) {
                if (isEpstein(msg.sender)) epsteinSent = true;
                if (epsteinInList(msg.receivers)) epsteinReceived = true;
            }

            return epsteinReceived && !epsteinSent;
        }

        function processData() {
            personConnections = {};

            // Filter out single-message threads where Epstein doesn't respond
            data = data.filter(thread => !shouldExcludeThread(thread));

            // Count how many threads each person appears in (using consolidated names)
            const personThreadCount = {};
            data.forEach(thread => {
                const allInThread = new Set([
                    ...(thread.senders || []),
                    ...(thread.receivers || []),
                    ...(thread.people_mentioned || [])
                ].map(p => consolidateName(p)).filter(p => p && p.trim()));
                allInThread.forEach(p => {
                    personThreadCount[p] = (personThreadCount[p] || 0) + 1;
                });
            });

            // Only keep people who appear in 3+ threads
            const validPeople = new Set(Object.keys(personThreadCount).filter(p => personThreadCount[p] >= 3));

            data.forEach((thread, threadIndex) => {
                const allInThread = new Set([
                    ...(thread.senders || []),
                    ...(thread.receivers || []),
                    ...(thread.people_mentioned || [])
                ].map(p => consolidateName(p)).filter(p => p && p.trim() && validPeople.has(p)));

                const peopleArray = Array.from(allInThread);

                for (let i = 0; i < peopleArray.length; i++) {
                    const person1 = peopleArray[i];
                    if (!personConnections[person1]) {
                        personConnections[person1] = {};
                    }

                    for (let j = 0; j < peopleArray.length; j++) {
                        if (i !== j) {
                            const person2 = peopleArray[j];
                            if (!personConnections[person1][person2]) {
                                personConnections[person1][person2] = [];
                            }
                            personConnections[person1][person2].push(threadIndex);
                        }
                    }
                }
            });

            // Filter out people mentioned only once
            allPeople = Object.keys(personConnections)
                .filter(p => Object.keys(personConnections[p]).length > 1)
                .sort((a, b) => {
                    const countA = Object.keys(personConnections[a]).length;
                    const countB = Object.keys(personConnections[b]).length;
                    return countB - countA;
                });
        }

        function renderStats() {
            document.getElementById('stats').innerHTML = `
                <span><span class="stat-value">${allPeople.length}</span> people</span>
                <span><span class="stat-value">${data.length}</span> discussions</span>
            `;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function highlightNames(text, names) {
            if (!text || !names || names.length === 0) return escapeHtml(text);

            let escaped = escapeHtml(text);

            names.forEach(name => {
                if (!name) return;
                const escapedName = escapeHtml(name);
                const regex = new RegExp(`(${escapedName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                escaped = escaped.replace(regex, '<mark class="name-highlight">$1</mark>');
            });

            return escaped;
        }

        function renderPersonList1(filter = '') {
            const container = document.getElementById('personList1');
            let filtered = allPeople.filter(p =>
                p.toLowerCase().includes(filter.toLowerCase())
            );

            // Filter by cluster if selected
            if (selectedCluster !== null) {
                filtered = filtered.filter(p => personToCluster[p] === selectedCluster);
            }

            container.innerHTML = filtered.map(person => {
                const connectionCount = Object.keys(personConnections[person]).length;
                const isSelected = person === selectedPerson1;
                const clusterId = personToCluster[person];
                return `
                    <div class="person-item ${isSelected ? 'selected' : ''}"
                         data-person="${escapeHtml(person)}">
                        <span>${escapeHtml(person)}</span>
                        <span class="person-count">${connectionCount}</span>
                    </div>
                `;
            }).join('');

            container.querySelectorAll('.person-item').forEach(el => {
                el.addEventListener('click', () => selectPerson1(el.dataset.person));
            });
        }

        function selectPerson1(person) {
            selectedPerson1 = person;
            selectedPerson2 = null;
            renderPersonList1(document.getElementById('searchPerson1').value);
            renderRelationshipInfo();
            renderPersonList2();
            document.getElementById('discussions').innerHTML =
                '<div class="empty-state">Select a connection to see shared discussions</div>';
        }

        function renderRelationshipInfo() {
            const container = document.getElementById('relationshipInfo');

            if (!selectedPerson1) {
                container.innerHTML = '';
                return;
            }

            const rel = personRelationships[selectedPerson1];
            const existingFeedback = feedbacks[selectedPerson1] || '';

            if (!rel) {
                container.innerHTML = `
                    <div class="relationship-box">
                        <div class="relationship-title">Relationship with Epstein</div>
                        <div class="relationship-text" style="color: #888; font-style: italic;">
                            No relationship data available for this person.
                        </div>
                        ${renderFeedbackSection(selectedPerson1, existingFeedback)}
                    </div>
                `;
                return;
            }

            const threadLinks = (rel.thread_ids || []).slice(0, 5).map(tid =>
                `<span class="thread-link" onclick="showThreadById('${escapeHtml(tid)}')">${escapeHtml(tid.substring(0, 30))}...</span>`
            ).join('');

            container.innerHTML = `
                <div class="relationship-box">
                    <div class="relationship-title">Relationship with Epstein</div>
                    <div class="relationship-text">${escapeHtml(rel.relationship)}</div>
                    <div class="relationship-count">Appears in ${rel.count} discussions</div>
                    ${threadLinks ? `
                        <div class="thread-links">
                            <div class="thread-links-title">Source emails (click to view):</div>
                            ${threadLinks}
                        </div>
                    ` : ''}
                    ${renderFeedbackSection(selectedPerson1, existingFeedback)}
                </div>
            `;
        }

        function renderFeedbackSection(personName, existingFeedback) {
            return `
                <div class="feedback-section">
                    <div class="feedback-label">Your feedback / comment:</div>
                    ${existingFeedback ? `<div class="feedback-existing">${escapeHtml(existingFeedback)}</div>` : ''}
                    <textarea class="feedback-input" id="feedbackInput" placeholder="Add your comment here...">${escapeHtml(existingFeedback)}</textarea>
                    <button class="feedback-btn feedback-btn-save" onclick="saveFeedbackForPerson()">Save Feedback</button>
                </div>
            `;
        }

        function saveFeedbackForPerson() {
            if (!selectedPerson1) return;
            const input = document.getElementById('feedbackInput');
            const comment = input.value.trim();
            if (comment) {
                saveFeedback(selectedPerson1, comment);
                renderRelationshipInfo();
            }
        }

        function showThreadById(threadId) {
            const threadIndex = data.findIndex(d => d.thread_id === threadId);
            if (threadIndex === -1) {
                alert('Thread not found: ' + threadId);
                return;
            }

            const thread = data[threadIndex];
            const container = document.getElementById('discussions');

            const messagesHtml = (thread.messages || []).map(msg => {
                const sender = msg.sender || 'Unknown';
                const receivers = (msg.receivers || []).join(', ') || 'Unknown';

                return `
                    <div class="message">
                        <div class="message-header">
                            <div>
                                <span class="message-sender">${escapeHtml(sender)}</span>
                                <span class="message-receivers">â†’ ${escapeHtml(receivers)}</span>
                            </div>
                            <div class="message-date">${escapeHtml(msg.date || '')}</div>
                        </div>
                        <div class="message-body">${escapeHtml(msg.body || '')}</div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `
                <div class="discussion-card">
                    <div class="discussion-header">
                        <div class="discussion-subject">${escapeHtml(thread.subject || 'No subject')}</div>
                        <div class="discussion-meta">
                            ${thread.message_count} message${thread.message_count !== 1 ? 's' : ''}<br>
                            <small style="color:#666">${escapeHtml(threadId)}</small>
                        </div>
                    </div>
                    <div class="messages-container">
                        ${messagesHtml}
                    </div>
                </div>
            `;
        }

        function renderPersonList2(filter = '') {
            const container = document.getElementById('personList2');

            if (!selectedPerson1) {
                container.innerHTML = '<div class="empty-state">Select a person to see their connections</div>';
                return;
            }

            const connections = personConnections[selectedPerson1] || {};
            let connectedPeople = Object.keys(connections).sort((a, b) => {
                return connections[b].length - connections[a].length;
            });

            if (filter) {
                connectedPeople = connectedPeople.filter(p =>
                    p.toLowerCase().includes(filter.toLowerCase())
                );
            }

            if (connectedPeople.length === 0) {
                container.innerHTML = '<div class="empty-state">No connections found</div>';
                return;
            }

            container.innerHTML = connectedPeople.map(person => {
                const threadCount = connections[person].length;
                const isSelected = person === selectedPerson2;
                return `
                    <div class="person-item ${isSelected ? 'selected' : ''}"
                         data-person="${escapeHtml(person)}">
                        <span>${escapeHtml(person)}</span>
                        <span class="person-count">${threadCount}</span>
                    </div>
                `;
            }).join('');

            container.querySelectorAll('.person-item').forEach(el => {
                el.addEventListener('click', () => selectPerson2(el.dataset.person));
            });
        }

        function selectPerson2(person) {
            selectedPerson2 = person;
            renderPersonList2(document.getElementById('searchPerson2').value);
            renderDiscussions();
        }

        function renderDiscussions() {
            const container = document.getElementById('discussions');

            if (!selectedPerson1 || !selectedPerson2) {
                container.innerHTML = '<div class="empty-state">Select two people to see their shared discussions</div>';
                return;
            }

            const threadIndices = personConnections[selectedPerson1][selectedPerson2] || [];

            if (threadIndices.length === 0) {
                container.innerHTML = '<div class="empty-state">No shared discussions found</div>';
                return;
            }

            container.innerHTML = threadIndices.map(idx => {
                const thread = data[idx];
                const allPeopleInThread = [
                    ...(thread.senders || []),
                    ...(thread.receivers || []),
                    ...(thread.people_mentioned || [])
                ].map(p => consolidateName(p)).filter((p, i, arr) => p && arr.indexOf(p) === i);

                // Get all receivers and senders across all messages for highlighting
                const allReceivers = (thread.messages || []).flatMap(m => m.receivers || []);
                const allSenders = (thread.messages || []).map(m => m.sender || '').filter(s => s);

                function nameMatches(a, b) {
                    if (!a || !b) return false;
                    // Compare consolidated versions
                    const aConsol = (consolidateName(a) || a).toLowerCase();
                    const bConsol = (consolidateName(b) || b).toLowerCase();
                    return aConsol === bConsol || aConsol.includes(bConsol) || bConsol.includes(aConsol);
                }

                const messagesHtml = (thread.messages || []).map(msg => {
                    const receivers = msg.receivers || [];
                    const sender = msg.sender || '';

                    // Check which selected persons are sender/receiver
                    const senderIsSelected1 = nameMatches(sender, selectedPerson1);
                    const senderIsSelected2 = nameMatches(sender, selectedPerson2);
                    const receiverHasSelected1 = receivers.some(r => nameMatches(r, selectedPerson1));
                    const receiverHasSelected2 = receivers.some(r => nameMatches(r, selectedPerson2));

                    // Highlight sender if selected
                    const senderHtml = (senderIsSelected1 || senderIsSelected2)
                        ? `<mark class="name-highlight">${escapeHtml(sender || 'Unknown')}</mark>`
                        : escapeHtml(sender || 'Unknown');

                    // Highlight receivers if selected
                    const receiversHtml = receivers.map(r => {
                        if (nameMatches(r, selectedPerson1) || nameMatches(r, selectedPerson2)) {
                            return `<mark class="name-highlight">${escapeHtml(r)}</mark>`;
                        }
                        return escapeHtml(r);
                    }).join(', ') || 'Unknown';

                    // Names to highlight in body
                    const namesToHighlight = [selectedPerson1, selectedPerson2].filter(name =>
                        receivers.some(r => nameMatches(r, name)) || nameMatches(sender, name)
                    );

                    return `
                    <div class="message">
                        <div class="message-header">
                            <div>
                                <span class="message-sender">${senderHtml}</span>
                                <span class="message-receivers">â†’ ${receiversHtml}</span>
                            </div>
                            <div class="message-date">${escapeHtml(msg.date || '')}</div>
                        </div>
                        <div class="message-body">${highlightNames(msg.body || '', namesToHighlight)}</div>
                    </div>
                `}).join('');

                return `
                    <div class="discussion-card">
                        <div class="discussion-metadata">
                            ${thread.relationship ? `<span class="metadata-tag metadata-relationship">${escapeHtml(thread.relationship)}</span>` : ''}
                            ${thread.topic ? `<span class="metadata-tag metadata-topic">${escapeHtml(thread.topic)}</span>` : ''}
                        </div>
                        <div class="discussion-header">
                            <div class="discussion-subject">${escapeHtml(thread.subject || 'No subject')}</div>
                            <div class="discussion-meta">
                                ${thread.message_count} message${thread.message_count !== 1 ? 's' : ''}
                            </div>
                        </div>
                        <div class="messages-container">
                            ${messagesHtml}
                        </div>
                        <div class="discussion-people">
                            ${allPeopleInThread.map(p => {
                                const isReceiver = allReceivers.some(r => nameMatches(r, p));
                                const isSender = allSenders.some(s => nameMatches(s, p));
                                const isSelected = nameMatches(p, selectedPerson1) || nameMatches(p, selectedPerson2);
                                return `<span class="person-tag ${isSelected && (isReceiver || isSender) ? 'highlighted' : ''}">${escapeHtml(p)}</span>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        document.getElementById('searchPerson1').addEventListener('input', (e) => {
            renderPersonList1(e.target.value);
        });

        document.getElementById('searchPerson2').addEventListener('input', (e) => {
            renderPersonList2(e.target.value);
        });

        loadData();
    </script>
</body>
</html>
